# build_vacancies_limerick_enhanced.py
# FULLY ROBUST VERSION - Complete interactive visualization with pie charts
# All features: comprehensive filters, legends, stats, mode switching, detailed hover cards
# FIXED: Pie chart colors now correctly update when switching between Urgency and Reason modes

import json, time, random
import pandas as pd
import numpy as np
from pathlib import Path
from geopy.geocoders import Nominatim
from datetime import datetime, timedelta
from collections import defaultdict

CSV = "cleaned_vacant_properties.csv"
CACHE = "geocode_cache.json"
OUT = "vacancies_limerick.html"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEMPORAL THRESHOLDS - Define urgency tiers
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
URGENCY_TIERS = {
    "routine": {"max_weeks": 8, "label": "Routine Maintenance", "priority": 1},
    "concerning": {"max_weeks": 26, "label": "Concerning (2-6 months)", "priority": 2},
    "urgent": {"max_weeks": 52, "label": "Urgent (6-12 months)", "priority": 3},
    "critical": {"max_weeks": 104, "label": "Critical (1-2 years)", "priority": 4},
    "crisis": {"max_weeks": float('inf'), "label": "Crisis (2+ years)", "priority": 5}
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Load and preprocess data
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
df = pd.read_csv(CSV)
df.columns = [c.strip() for c in df.columns]
df = df[df["Address"].notna()].copy()
df["Address"] = df["Address"].str.strip()
df["Reason"] = df["Reason"].fillna("Unknown")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Load / init cache
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cache_path = Path(CACHE)
cache = json.loads(cache_path.read_text()) if cache_path.exists() else {}

def save_cache():
    cache_path.write_text(json.dumps(cache, indent=2))

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Geocoder (same one that worked)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
geolocator = Nominatim(user_agent="limerick_vacancy_mapper")

def geocode(addr):
    if addr in cache:
        return cache[addr]

    q = f"{addr}, Limerick, Ireland"
    try:
        loc = geolocator.geocode(q, timeout=15)
        if loc:
            cache[addr] = {"lon": loc.longitude, "lat": loc.latitude}
            print(f"âœ“ {addr}")
            save_cache()
            time.sleep(5 + random.random() * 5)  # 5â€“10 s delay
            return cache[addr]
    except Exception as e:
        print(f"âš ï¸ {addr}: {e}")
        time.sleep(10)
    cache[addr] = None
    save_cache()
    print(f"âœ— {addr}")
    return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Run geocoding
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
addresses = df["Address"].unique()
remaining = [a for a in addresses if not cache.get(a)]
print(f"\nğŸ“ {len(remaining)} addresses to geocode (slow mode)\n")

for i, a in enumerate(remaining, 1):
    geocode(a)
    if i % 5 == 0:
        print(f"ğŸ’¾ progress: {i}/{len(remaining)} ({i/len(remaining):.1%})")

print("\nâœ… Geocoding complete.\n")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Merge coords
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
df["lon"] = df["Address"].map(lambda a: cache.get(a, {}).get("lon"))
df["lat"] = df["Address"].map(lambda a: cache.get(a, {}).get("lat"))
df = df.dropna(subset=["lon", "lat"])

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Classify urgency
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def classify_urgency(weeks):
    """Classify vacancy duration into urgency tier"""
    for tier, info in URGENCY_TIERS.items():
        if weeks <= info["max_weeks"]:
            return tier
    return "crisis"

df["urgency_tier"] = df["No of Weeks Vacated"].apply(classify_urgency)
df["urgency_priority"] = df["urgency_tier"].map(
    lambda t: URGENCY_TIERS[t]["priority"]
)

# Calculate cost burden (estimated weekly housing cost in Ireland ~â‚¬350)
df["estimated_cost_burden"] = df["No of Weeks Vacated"] * 350

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Cluster overlapping properties (distance-based grouping)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def cluster_nearby_properties(df, threshold_meters=50):
    """
    Group properties that are very close together.
    Uses simple distance threshold clustering.
    """
    from math import radians, cos, sin, asin, sqrt
    
    def haversine(lon1, lat1, lon2, lat2):
        """Calculate distance between two lat/lon points in meters"""
        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        return c * 6371000  # Earth radius in meters
    
    clusters = []
    used = set()
    
    for i, row1 in df.iterrows():
        if i in used:
            continue
        
        cluster = [i]
        used.add(i)
        
        for j, row2 in df.iterrows():
            if j in used or i == j:
                continue
            
            dist = haversine(row1['lon'], row1['lat'], row2['lon'], row2['lat'])
            if dist < threshold_meters:
                cluster.append(j)
                used.add(j)
        
        clusters.append(cluster)
    
    return clusters

clusters = cluster_nearby_properties(df, threshold_meters=50)
print(f"\nğŸ”— Found {len(clusters)} location clusters")
print(f"   â€¢ {sum(1 for c in clusters if len(c) > 1)} clusters with multiple properties")

# Add cluster ID to dataframe
cluster_map = {}
for cluster_id, indices in enumerate(clusters):
    for idx in indices:
        cluster_map[idx] = cluster_id

df['cluster_id'] = df.index.map(cluster_map)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enhanced color schemes with better visual hierarchy
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
URGENCY_COLORS = {
    "routine": "#bdc3c7",      # Light gray - barely noticeable
    "concerning": "#f1c40f",   # Yellow - attention
    "urgent": "#e67e22",       # Orange - concern
    "critical": "#e74c3c",     # Red - serious
    "crisis": "#8b0000"        # Dark red - emergency
}

REASON_COLORS = {
    "Allocated": "#27ae60",
    "Awaiting Minor Repairs": "#3498db",
    "To Be Allocated": "#f39c12",
    "For Demolition": "#8e44ad",
    "Major Refurbishment": "#e67e22",
    "Section 183": "#c0392b",
    "On-hold": "#7f8c8d",
    "Demountable": "#95a5a6",
    "Unknown": "#34495e"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Statistical aggregations for dashboard
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
stats = {
    "total_properties": len(df),
    "total_clusters": len(clusters),
    "total_weeks_vacant": int(df["No of Weeks Vacated"].sum()),
    "avg_vacancy_weeks": float(df["No of Weeks Vacated"].mean()),
    "median_vacancy_weeks": float(df["No of Weeks Vacated"].median()),
    "total_cost_burden": int(df["estimated_cost_burden"].sum()),
    "by_urgency": df.groupby("urgency_tier").size().to_dict(),
    "by_reason": df.groupby("Reason").size().to_dict(),
    "longest_vacant": {
        "address": df.loc[df["No of Weeks Vacated"].idxmax(), "Address"],
        "weeks": int(df["No of Weeks Vacated"].max()),
        "years": round(df["No of Weeks Vacated"].max() / 52, 1)
    }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Build cluster-aware data structure with urgency composition
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cluster_data = []

for cluster_id, indices in enumerate(clusters):
    cluster_df = df.loc[indices]
    
    # Calculate cluster centroid
    center_lon = cluster_df['lon'].mean()
    center_lat = cluster_df['lat'].mean()
    
    # Aggregate cluster metrics
    total_weeks = cluster_df["No of Weeks Vacated"].sum()
    max_weeks = cluster_df["No of Weeks Vacated"].max()
    min_weeks = cluster_df["No of Weeks Vacated"].min()
    avg_weeks = cluster_df["No of Weeks Vacated"].mean()
    
    # Get urgency composition (count each tier)
    urgency_composition = cluster_df["urgency_tier"].value_counts().to_dict()
    
    # Get worst urgency in cluster
    worst_priority = cluster_df["urgency_priority"].max()
    worst_urgency = cluster_df.loc[cluster_df["urgency_priority"].idxmax(), "urgency_tier"]
    
    # Build property list
    properties = []
    for idx, row in cluster_df.iterrows():
        weeks = int(row["No of Weeks Vacated"])
        properties.append({
            "address": row["Address"],
            "reason": row["Reason"],
            "weeks": weeks,
            "years": round(weeks / 52, 1),
            "months": round(weeks / 4.33, 1),
            "urgency_tier": row["urgency_tier"],
            "urgency_priority": int(row["urgency_priority"]),
            "urgency_color": URGENCY_COLORS[row["urgency_tier"]],
            "reason_color": REASON_COLORS.get(row["Reason"], "#34495e"),
            "cost_burden": int(row["estimated_cost_burden"])
        })
    
    # Sort properties by urgency (worst first)
    properties.sort(key=lambda p: -p["urgency_priority"])
    
    # Build reason composition for Reason mode pie charts
    reason_composition = cluster_df["Reason"].value_counts().to_dict()
    
    cluster_data.append({
        "cluster_id": cluster_id,
        "lon": float(center_lon),
        "lat": float(center_lat),
        "property_count": len(properties),
        "properties": properties,
        "total_weeks": int(total_weeks),
        "max_weeks": int(max_weeks),
        "min_weeks": int(min_weeks),
        "avg_weeks": round(avg_weeks, 1),
        "worst_urgency": worst_urgency,
        "worst_priority": int(worst_priority),
        "urgency_composition": urgency_composition,  # How many of each tier
        "reason_composition": reason_composition,  # How many of each reason
        "urgency_color": URGENCY_COLORS[worst_urgency],
        "total_cost": sum(p["cost_burden"] for p in properties)
    })

payload = json.dumps({
    "clusters": cluster_data,
    "stats": stats,
    "urgency_colors": URGENCY_COLORS,
    "reason_colors": REASON_COLORS,
    "urgency_tiers": {k: v for k, v in URGENCY_TIERS.items()}
}, ensure_ascii=False)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enhanced HTML with all robust features + FIXED pie charts
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
HTML = r"""<!doctype html>
<html lang="en"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Limerick Vacant Properties</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; }
#map { position: absolute; inset: 0; }

.header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 9998;
    background: linear-gradient(135deg, rgba(44,62,80,0.97), rgba(52,73,94,0.97));
    color: white; padding: 12px 20px; box-shadow: 0 2px 20px rgba(0,0,0,0.3);
}
.header-content { max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
.header h1 { font-size: 20px; font-weight: 600; }
.header-stats { display: flex; gap: 25px; font-size: 13px; flex-wrap: wrap; }
.stat-item { display: flex; flex-direction: column; align-items: center; }
.stat-value { font-size: 24px; font-weight: 700; color: #3498db; }
.stat-label { font-size: 11px; opacity: 0.85; margin-top: 2px; }

.controls {
    position: fixed; top: 80px; left: 20px; z-index: 9999;
    background: rgba(255,255,255,0.97); border-radius: 12px;
    padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); width: 280px;
}
.control-section { margin-bottom: 15px; }
.control-section:last-child { margin-bottom: 0; }
.control-label { font-size: 12px; font-weight: 600; color: #2c3e50; margin-bottom: 8px; display: block; }
.view-mode { display: flex; gap: 8px; }
.mode-btn {
    flex: 1; padding: 8px 12px; border: 2px solid #ddd; background: white;
    border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600;
    transition: all 0.2s; text-align: center;
}
.mode-btn.active { background: #3498db; color: white; border-color: #3498db; }
.mode-btn:hover:not(.active) { border-color: #3498db; background: #ecf0f1; }

.filter-section { margin-top: 12px; }
.urgency-filters { display: flex; flex-direction: column; gap: 6px; }
.urgency-filter {
    display: flex; align-items: center; gap: 8px; padding: 6px 8px;
    border-radius: 6px; cursor: pointer; transition: background 0.2s;
}
.urgency-filter:hover { background: #ecf0f1; }
.urgency-filter input[type="checkbox"] { cursor: pointer; }
.urgency-dot { width: 12px; height: 12px; border-radius: 50%; }
.urgency-label { font-size: 11px; flex: 1; }
.urgency-count { font-size: 11px; font-weight: 600; color: #7f8c8d; }

.legend {
    position: fixed; bottom: 20px; right: 20px; z-index: 9999;
    background: rgba(255,255,255,0.97); border-radius: 12px;
    padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); max-width: 300px;
}
.legend-title { font-size: 13px; font-weight: 700; color: #2c3e50; margin-bottom: 10px; }
.legend-item { display: flex; align-items: center; gap: 10px; margin: 6px 0; font-size: 11px; }
.legend-dot { width: 14px; height: 14px; border-radius: 50%; flex-shrink: 0; }
.legend-label { flex: 1; color: #34495e; }
.legend-value { font-weight: 600; color: #7f8c8d; }

.hovercard {
    position: fixed; z-index: 10000; pointer-events: none;
    background: rgba(255,255,255,0.98); border: 2px solid #3498db;
    border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    padding: 12px 14px; font-size: 12px; display: none; max-width: 380px;
    max-height: 70vh; overflow-y: auto;
}
.hovercard-header { 
    font-weight: 700; font-size: 14px; color: #2c3e50; 
    margin-bottom: 10px; border-bottom: 2px solid #3498db; padding-bottom: 8px; 
}
.cluster-summary {
    background: #ecf0f1; padding: 8px 10px; border-radius: 6px; margin-bottom: 10px;
    font-size: 11px;
}
.composition-bar {
    display: flex; height: 8px; border-radius: 4px; overflow: hidden; margin: 6px 0;
}
.composition-segment { height: 100%; }
.property-item {
    background: #f8f9fa; border-left: 4px solid #3498db;
    padding: 8px 10px; margin: 8px 0; border-radius: 4px;
}
.property-header {
    font-weight: 600; color: #2c3e50; margin-bottom: 4px; font-size: 11px;
}
.property-detail { font-size: 10px; color: #7f8c8d; margin: 2px 0; }
.urgency-badge {
    display: inline-block; padding: 2px 6px; border-radius: 3px;
    font-size: 9px; font-weight: 700; color: white; margin-left: 6px;
}

@media (max-width: 768px) {
    .controls { width: 240px; top: 100px; }
    .legend { bottom: 10px; right: 10px; max-width: 200px; }
}
</style>
</head><body>

<div class="header">
    <div class="header-content">
        <h1>ğŸ˜ï¸ Limerick Vacant Properties</h1>
        <div class="header-stats">
            <div class="stat-item">
                <div class="stat-value" id="stat-total">0</div>
                <div class="stat-label">Properties</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stat-locations">0</div>
                <div class="stat-label">Locations</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stat-avg">0</div>
                <div class="stat-label">Avg. Weeks</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="stat-crisis">0</div>
                <div class="stat-label">Crisis (2+ yrs)</div>
            </div>
        </div>
    </div>
</div>

<div id="map"></div>
<div id="card" class="hovercard"></div>

<div class="controls">
    <div class="control-section">
        <span class="control-label">Color by</span>
        <div class="view-mode">
            <button class="mode-btn active" data-mode="urgency">Urgency</button>
            <button class="mode-btn" data-mode="reason">Reason</button>
        </div>
    </div>
    
    <div class="control-section filter-section">
        <span class="control-label">Filter by Urgency</span>
        <div class="urgency-filters" id="urgency-filters"></div>
    </div>
</div>

<div class="legend" id="legend"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>
<script>
const DATA = __DATA__;
let currentMode = 'urgency';
let activeFilters = new Set(['routine', 'concerning', 'urgent', 'critical', 'crisis']);

// Initialize map
const map = L.map('map', {
    zoomControl: true,
    preferCanvas: false
}).setView([52.66, -8.63], 12);

L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '&copy; OSM contributors'
}).addTo(map);

// Create SVG overlay
const svg = d3.select(map.getPanes().overlayPane)
    .append('svg')
    .attr('class', 'leaflet-zoom-hide')
    .style('position', 'absolute')
    .style('z-index', '650');

const g = svg.append('g').attr('class', 'leaflet-zoom-hide');
const gCircles = g.append('g').attr('class', 'circles');

const card = document.getElementById('card');

// Update stats
document.getElementById('stat-total').textContent = DATA.stats.total_properties;
document.getElementById('stat-locations').textContent = DATA.stats.total_clusters;
document.getElementById('stat-avg').textContent = Math.round(DATA.stats.avg_vacancy_weeks);
document.getElementById('stat-crisis').textContent = DATA.stats.by_urgency.crisis || 0;

// Resize and reposition SVG to match map bounds
function resetSvg() {
    const bounds = map.getBounds();
    const topLeft = map.latLngToLayerPoint(bounds.getNorthWest());
    const bottomRight = map.latLngToLayerPoint(bounds.getSouthEast());
    
    const width = bottomRight.x - topLeft.x;
    const height = bottomRight.y - topLeft.y;
    
    svg
        .attr('width', width)
        .attr('height', height)
        .style('left', topLeft.x + 'px')
        .style('top', topLeft.y + 'px');
    
    g.attr('transform', `translate(${-topLeft.x},${-topLeft.y})`);
}

map.on('resize', resetSvg);
map.on('viewreset', resetSvg);
map.on('zoom', resetSvg);
map.on('move', resetSvg);
resetSvg();

// Card functions with click-to-pin behavior
let currentCluster = null;
let isCardPinned = false;

function showCard(cluster, event, shouldPin = false) {
    currentCluster = cluster;
    
    if (shouldPin) {
        isCardPinned = true;
    }
    
    const showExpanded = isCardPinned;
    
    let html = `<div class="hovercard-header">`;
    
    if (cluster.property_count > 1) {
        html += `${cluster.property_count} Properties at this Location`;
        if (isCardPinned) {
            html += ` <span style="color: #27ae60; font-size: 11px;">ğŸ“Œ Pinned</span>`;
        }
    } else {
        html += cluster.properties[0].address;
    }
    
    html += `</div>`;
    
    // Show cluster summary for multi-property locations
    if (cluster.property_count > 1) {
        html += `<div class="cluster-summary">`;
        html += `<strong>Total vacant:</strong> ${cluster.total_weeks} weeks<br>`;
        html += `<strong>Range:</strong> ${cluster.min_weeks} - ${cluster.max_weeks} weeks<br>`;
        html += `<strong>Average:</strong> ${cluster.avg_weeks} weeks<br>`;
        html += `<strong>Total cost:</strong> â‚¬${(cluster.total_cost/1000).toFixed(1)}k`;
        
        // Show urgency composition bar
        const tierOrder = ['routine', 'concerning', 'urgent', 'critical', 'crisis'];
        html += `<div style="margin-top: 8px;"><strong>Urgency Mix:</strong></div>`;
        html += `<div class="composition-bar">`;
        tierOrder.forEach(tier => {
            const count = cluster.urgency_composition[tier] || 0;
            if (count > 0) {
                const percentage = (count / cluster.property_count) * 100;
                html += `<div class="composition-segment" style="width: ${percentage}%; background: ${DATA.urgency_colors[tier]}" title="${DATA.urgency_tiers[tier].label}: ${count}"></div>`;
            }
        });
        html += `</div>`;
        
        // List urgency counts
        html += `<div style="font-size: 10px; margin-top: 4px;">`;
        tierOrder.forEach(tier => {
            const count = cluster.urgency_composition[tier] || 0;
            if (count > 0) {
                html += `<span style="color: ${DATA.urgency_colors[tier]}">â— ${count} ${DATA.urgency_tiers[tier].label}</span> `;
            }
        });
        html += `</div>`;
        
        html += `</div>`;
    }
    
    // Determine how many properties to show
    const showCount = showExpanded ? cluster.property_count : Math.min(3, cluster.property_count);
    const hasMore = cluster.property_count > 3;
    
    // Show each property
    cluster.properties.slice(0, showCount).forEach((prop) => {
        const durationText = prop.years >= 1 ? `${prop.years} years` : `${prop.months} months`;
        const urgencyLabel = DATA.urgency_tiers[prop.urgency_tier].label;
        
        html += `
            <div class="property-item" style="border-left-color: ${prop.urgency_color}">
                <div class="property-header">
                    ${prop.address}
                    <span class="urgency-badge" style="background:${prop.urgency_color}">${urgencyLabel}</span>
                </div>
                <div class="property-detail"><strong>Status:</strong> ${prop.reason}</div>
                <div class="property-detail"><strong>Vacant:</strong> ${durationText} (${prop.weeks} weeks)</div>
                <div class="property-detail"><strong>Est. cost:</strong> â‚¬${(prop.cost_burden/1000).toFixed(1)}k</div>
            </div>
        `;
    });
    
    // Show hint if there are more properties
    if (hasMore && !isCardPinned) {
        html += `
            <div style="text-align: center; padding: 10px; margin-top: 10px; 
                        background: linear-gradient(135deg, #3498db, #2980b9); 
                        border-radius: 8px; font-size: 12px; color: white;
                        font-weight: 600; box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);">
                ğŸ‘† Click circle to pin & see all ${cluster.property_count} properties
            </div>
        `;
    }
    
    card.innerHTML = html;
    card.style.display = 'block';
    
    // Make card scrollable when pinned
    if (isCardPinned) {
        card.style.pointerEvents = 'auto';
    } else {
        card.style.pointerEvents = 'none';
    }
    
    // Position card
    const x = event.pageX || event.clientX;
    const y = event.pageY || event.clientY;
    const cardWidth = 380;
    const cardHeight = card.offsetHeight;
    let left = x + 15;
    let top = y + 15;
    
    if (left + cardWidth > window.innerWidth) {
        left = x - cardWidth - 15;
    }
    if (top + cardHeight > window.innerHeight) {
        top = window.innerHeight - cardHeight - 20;
    }
    if (left < 0) left = 10;
    if (top < 0) top = 10;
    
    card.style.left = left + 'px';
    card.style.top = top + 'px';
}

function hideCard() { 
    card.style.display = 'none';
    card.style.pointerEvents = 'none';
    currentCluster = null;
    isCardPinned = false;
}

map.on('movestart', hideCard);
map.on('zoomstart', hideCard);
map.on('click', hideCard);

// Calculate radius based on zoom and property count
const BASE_SIZE = 6;
function getRadius(cluster, zoom) {
    const zoomFactor = Math.pow(1.3, zoom - 12); // Scale with zoom
    const countFactor = Math.sqrt(cluster.property_count); // Scale with property count
    return Math.max(4, Math.min(40, BASE_SIZE * zoomFactor * countFactor));
}

// Get color for cluster based on mode
function getColor(cluster) {
    if (currentMode === 'urgency') {
        return cluster.urgency_color;
    } else {
        // Use worst property's reason color
        return cluster.properties[0].reason_color;
    }
}

// Filter clusters based on active urgency filters
function getFilteredClusters() {
    return DATA.clusters.filter(c => {
        // Include if ANY property matches active filters
        return c.properties.some(p => activeFilters.has(p.urgency_tier));
    });
}

// Draw circles with PIE CHART composition - FIXED VERSION
let dotSelection;

function updateCircles() {
    const filteredClusters = getFilteredClusters();
    const zoom = map.getZoom();
    
    // Update SVG positioning
    resetSvg();
    
    const clusters = gCircles.selectAll('g.vacancy-cluster')
        .data(filteredClusters, d => d.cluster_id);
    
    // Remove old clusters
    clusters.exit().remove();
    
    // Add new cluster groups
    const enter = clusters.enter()
        .append('g')
        .attr('class', 'vacancy-cluster')
        .style('cursor', 'pointer');
    
    // Build each cluster
    enter.each(function(d) {
        const grp = d3.select(this);
        const r = getRadius(d, zoom);
        
        if (d.property_count === 1) {
            // Single property - solid circle
            const fillColor = currentMode === 'urgency' ? d.urgency_color : d.properties[0].reason_color;
            
            grp.append('circle')
                .attr('class', 'main-circle')
                .attr('r', r)
                .attr('fill', fillColor)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('opacity', 0.85);
        } else {
            // Multi-property - draw pie slices in urgency mode
            if (currentMode === 'urgency') {
                const tiers = ['routine', 'concerning', 'urgent', 'critical', 'crisis'];
                let ang = -Math.PI / 2; // Start at top
                
                tiers.forEach(tier => {
                    const cnt = d.urgency_composition[tier] || 0;
                    if (cnt > 0) {
                        const span = (cnt / d.property_count) * 2 * Math.PI;
                        const end = ang + span;
                        
                        // Calculate slice path
                        const x1 = Math.cos(ang) * r;
                        const y1 = Math.sin(ang) * r;
                        const x2 = Math.cos(end) * r;
                        const y2 = Math.sin(end) * r;
                        
                        const largeArcFlag = span > Math.PI ? 1 : 0;
                        
                        const pathData = [
                            `M 0 0`,
                            `L ${x1} ${y1}`,
                            `A ${r} ${r} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
                            `Z`
                        ].join(' ');
                        
                        grp.append('path')
                            .attr('class', 'pie-slice')
                            .attr('d', pathData)
                            .attr('fill', DATA.urgency_colors[tier])
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 1)
                            .attr('opacity', 0.9);
                        
                        ang = end;
                    }
                });
                
                // Add outer border
                grp.append('circle')
                    .attr('class', 'border-circle')
                    .attr('r', r)
                    .attr('fill', 'none')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2.5);
            } else {
                // Reason mode: solid circle with worst property's reason color
                grp.append('circle')
                    .attr('class', 'main-circle')
                    .attr('r', r)
                    .attr('fill', d.properties[0].reason_color)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.85);
            }
        }
        
        // Add invisible larger hitbox for easier clicking
        grp.append('circle')
            .attr('class', 'hitbox')
            .attr('r', r * 2.5)
            .attr('fill', 'transparent')
            .attr('stroke', 'none')
            .style('pointer-events', 'all');
    });
    
    // Add interaction handlers
    enter
        .on('mouseenter', function(event, d) {
            if (!isCardPinned) {
                d3.select(this).raise();
                d3.select(this).selectAll('circle.main-circle, path.pie-slice')
                    .transition()
                    .duration(150)
                    .attr('opacity', 1);
                
                d3.select(this).selectAll('circle')
                    .transition()
                    .duration(150)
                    .attr('stroke-width', d.property_count === 1 ? 3.5 : 4);
                
                showCard(d, event, false);
            }
        })
        .on('mousemove', function(event, d) {
            if (!isCardPinned) {
                showCard(d, event, false);
            }
        })
        .on('mouseleave', function(event, d) {
            if (!isCardPinned) {
                d3.select(this).selectAll('circle.main-circle, path.pie-slice')
                    .transition()
                    .duration(150)
                    .attr('opacity', d.property_count === 1 ? 0.85 : 0.9);
                
                d3.select(this).selectAll('circle.main-circle')
                    .transition()
                    .duration(150)
                    .attr('stroke-width', 2);
                
                d3.select(this).selectAll('circle.border-circle')
                    .transition()
                    .duration(150)
                    .attr('stroke-width', 2.5);
                
                hideCard();
            }
        })
        .on('click', function(event, d) {
            event.preventDefault();
            event.stopPropagation();
            
            isCardPinned = true;
            showCard(d, event, true);
            
            // Reset all clusters
            d3.selectAll('g.vacancy-cluster')
                .selectAll('circle.main-circle, path.pie-slice')
                .transition()
                .duration(150)
                .attr('opacity', function() {
                    const parent = d3.select(this.parentNode);
                    const data = parent.datum();
                    return data && data.property_count === 1 ? 0.85 : 0.9;
                });
            
            d3.selectAll('g.vacancy-cluster')
                .selectAll('circle.main-circle')
                .transition()
                .duration(150)
                .attr('stroke-width', 2);
            
            d3.selectAll('g.vacancy-cluster')
                .selectAll('circle.border-circle')
                .transition()
                .duration(150)
                .attr('stroke-width', 2.5);
            
            // Highlight clicked cluster
            d3.select(this).raise();
            d3.select(this).selectAll('circle.main-circle, path.pie-slice')
                .transition()
                .duration(150)
                .attr('opacity', 1);
            
            d3.select(this).selectAll('circle')
                .transition()
                .duration(150)
                .attr('stroke-width', 5);
        });
    
    // Update existing + new
    dotSelection = clusters.merge(enter);
    
    updateCirclePositions();
}

// Update positions and sizes - FIXED TO PROPERLY HANDLE MODE SWITCHING
function updateCirclePositions() {
    if (!dotSelection) return;
    
    const zoom = map.getZoom();
    
    dotSelection.attr('transform', d => {
        const pos = map.latLngToLayerPoint([d.lat, d.lon]);
        return `translate(${pos.x},${pos.y})`;
    });
    
    // Update all clusters
    dotSelection.each(function(d) {
        const grp = d3.select(this);
        const r = getRadius(d, zoom);
        
        if (d.property_count === 1) {
            // Single property: update solid circle color based on mode
            grp.selectAll('circle.main-circle')
                .attr('r', r)
                .attr('fill', currentMode === 'urgency' ? d.urgency_color : d.properties[0].reason_color);
        } else {
            // Multi-property cluster - hide/show elements based on mode
            if (currentMode === 'urgency') {
                // Urgency mode: show pie chart composition
                grp.selectAll('circle.main-circle').style('display', 'none');
                grp.selectAll('path.pie-slice').style('display', null);
                grp.selectAll('circle.border-circle').style('display', null);
                
                // Rebuild pie slices with correct radius
                const tiers = ['routine', 'concerning', 'urgent', 'critical', 'crisis'];
                let ang = -Math.PI / 2;
                let sliceIdx = 0;
                
                tiers.forEach(tier => {
                    const cnt = d.urgency_composition[tier] || 0;
                    if (cnt > 0) {
                        const span = (cnt / d.property_count) * 2 * Math.PI;
                        const end = ang + span;
                        
                        const x1 = Math.cos(ang) * r;
                        const y1 = Math.sin(ang) * r;
                        const x2 = Math.cos(end) * r;
                        const y2 = Math.sin(end) * r;
                        
                        const largeArcFlag = span > Math.PI ? 1 : 0;
                        
                        const pathData = [
                            `M 0 0`,
                            `L ${x1} ${y1}`,
                            `A ${r} ${r} 0 ${largeArcFlag} 1 ${x2} ${y2}`,
                            `Z`
                        ].join(' ');
                        
                        grp.selectAll('path.pie-slice')
                            .filter((_, i) => i === sliceIdx)
                            .attr('d', pathData);
                        
                        ang = end;
                        sliceIdx++;
                    }
                });
                
                grp.selectAll('circle.border-circle').attr('r', r);
            } else {
                // Reason mode: show solid circle with reason color
                grp.selectAll('path.pie-slice').style('display', 'none');
                grp.selectAll('circle.border-circle').style('display', 'none');
                
                grp.selectAll('circle.main-circle')
                    .style('display', null)
                    .attr('r', r)
                    .attr('fill', d.properties[0].reason_color);
            }
        }
        
        // Update hitbox for all
        grp.selectAll('circle.hitbox').attr('r', r * 2.5);
    });
}

// Update on map events
function onMapMove() {
    resetSvg();
    updateCirclePositions();
}

function onMapZoom() {
    resetSvg();
    updateCirclePositions();
}

map.on('moveend', onMapMove);
map.on('zoomend', onMapZoom);

map.whenReady(() => { 
    updateCircles(); 
});

// Mode switching
document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn[data-mode]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMode = btn.dataset.mode;
        updateLegend();
        updateCircles();
    });
});

// Urgency filters
function createUrgencyFilters() {
    const container = document.getElementById('urgency-filters');
    const tierOrder = ['routine', 'concerning', 'urgent', 'critical', 'crisis'];
    
    tierOrder.forEach(tier => {
        const info = DATA.urgency_tiers[tier];
        const count = DATA.stats.by_urgency[tier] || 0;
        
        const div = document.createElement('div');
        div.className = 'urgency-filter';
        div.innerHTML = `
            <input type="checkbox" id="filter-${tier}" checked>
            <span class="urgency-dot" style="background:${DATA.urgency_colors[tier]}"></span>
            <span class="urgency-label">${info.label}</span>
            <span class="urgency-count">${count}</span>
        `;
        
        const checkbox = div.querySelector('input');
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                activeFilters.add(tier);
            } else {
                activeFilters.delete(tier);
            }
            updateCircles();
        });
        
        container.appendChild(div);
    });
}

// Legend
function updateLegend() {
    const legend = document.getElementById('legend');
    const colors = currentMode === 'urgency' ? DATA.urgency_colors : DATA.reason_colors;
    const title = currentMode === 'urgency' ? 'Urgency Level' : 'Vacancy Reason';
    
    let html = `<div class="legend-title">${title}</div>`;
    
    if (currentMode === 'urgency') {
        const tierOrder = ['routine', 'concerning', 'urgent', 'critical', 'crisis'];
        tierOrder.forEach(tier => {
            const info = DATA.urgency_tiers[tier];
            const count = DATA.stats.by_urgency[tier] || 0;
            html += `
                <div class="legend-item">
                    <span class="legend-dot" style="background:${colors[tier]}"></span>
                    <span class="legend-label">${info.label}</span>
                    <span class="legend-value">${count}</span>
                </div>
            `;
        });
        
        html += `<div style="margin-top: 10px; font-size: 10px; color: #7f8c8d; padding-top: 8px; border-top: 1px solid #ecf0f1;">`;
        html += `<strong>Circle size</strong> = # of properties<br>`;
        html += `<strong>Pie slices</strong> = urgency mix`;
        html += `</div>`;
    } else {
        Object.entries(DATA.stats.by_reason).forEach(([reason, count]) => {
            html += `
                <div class="legend-item">
                    <span class="legend-dot" style="background:${colors[reason] || '#34495e'}"></span>
                    <span class="legend-label">${reason}</span>
                    <span class="legend-value">${count}</span>
                </div>
            `;
        });
    }
    
    legend.innerHTML = html;
}

// Initialize
createUrgencyFilters();
updateLegend();

// Add click handler to close card when clicking map
map.on('click', hideCard);
</script>
</body></html>
""".replace("__DATA__", payload)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Save output with proper UTF-8 encoding
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Path(OUT).write_text(HTML, encoding="utf-8")

print(f"\nâœ… Enhanced visualization saved: {OUT}")
print(f"\nğŸ“Š Summary Statistics:")
print(f"   â€¢ Total properties: {stats['total_properties']}")
print(f"   â€¢ Total locations: {stats['total_clusters']}")
print(f"   â€¢ Multi-property locations: {sum(1 for c in cluster_data if c['property_count'] > 1)}")
print(f"   â€¢ Average vacancy: {stats['avg_vacancy_weeks']:.1f} weeks")
print(f"   â€¢ Median vacancy: {stats['median_vacancy_weeks']:.1f} weeks")
print(f"   â€¢ Longest vacant: {stats['longest_vacant']['address']} ({stats['longest_vacant']['years']} years)")
print(f"   â€¢ Total cost burden: â‚¬{stats['total_cost_burden']:,}")
print(f"\nğŸš¨ Urgency Breakdown:")
for tier in ['routine', 'concerning', 'urgent', 'critical', 'crisis']:
    count = stats['by_urgency'].get(tier, 0)
    pct = (count / stats['total_properties']) * 100
    print(f"   â€¢ {URGENCY_TIERS[tier]['label']}: {count} ({pct:.1f}%)")
print(f"\nğŸ¨ Multi-urgency clusters: {sum(1 for c in cluster_data if len(c['urgency_composition']) > 1)}")
print(f"   (These show pie charts with mixed composition)")
